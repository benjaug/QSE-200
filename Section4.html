<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>QSE 200 Sections - 2&nbsp; Section 4: Discrete Variable Representation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Section6.html" rel="next">
<link href="./Section2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Section 4: Discrete Variable Representation</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">QSE 200 Sections</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Section2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Section 2: Numerically Solving the TDSE</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Section4.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Section 4: Discrete Variable Representation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Section6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Section 6: An Intuitive Picture of Band Structure</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">References</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#motivating-the-sinc-basis-dvr" id="toc-motivating-the-sinc-basis-dvr" class="nav-link active" data-scroll-target="#motivating-the-sinc-basis-dvr"><span class="toc-section-number">2.1</span>  Motivating the Sinc-Basis DVR</a>
  <ul class="collapse">
  <li><a href="#interpreting-the-sinc-basis" id="toc-interpreting-the-sinc-basis" class="nav-link" data-scroll-target="#interpreting-the-sinc-basis"><span class="toc-section-number">2.1.1</span>  Interpreting the Sinc-Basis</a></li>
  </ul></li>
  <li><a href="#deriving-the-kinetic-energy-matrix" id="toc-deriving-the-kinetic-energy-matrix" class="nav-link" data-scroll-target="#deriving-the-kinetic-energy-matrix"><span class="toc-section-number">2.2</span>  Deriving the Kinetic Energy Matrix</a></li>
  <li><a href="#deriving-the-potential-energy-matrix" id="toc-deriving-the-potential-energy-matrix" class="nav-link" data-scroll-target="#deriving-the-potential-energy-matrix"><span class="toc-section-number">2.3</span>  Deriving the Potential Energy Matrix</a></li>
  <li><a href="#testing-the-dvr-code" id="toc-testing-the-dvr-code" class="nav-link" data-scroll-target="#testing-the-dvr-code"><span class="toc-section-number">2.4</span>  Testing the DVR code</a>
  <ul class="collapse">
  <li><a href="#comparing-dvr-to-finite-differences" id="toc-comparing-dvr-to-finite-differences" class="nav-link" data-scroll-target="#comparing-dvr-to-finite-differences"><span class="toc-section-number">2.4.1</span>  Comparing DVR to Finite Differences</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Section 4: Discrete Variable Representation</span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>Last week, we studied the connection between position and momentum space using Fourier transforms. We learned that we can work in either “position space” with basis states <span class="math inline">\(\langle x' | x \rangle = \delta(x-x')\)</span>, or in “momentum space” with basis states <span class="math inline">\(\langle k' | k \rangle = \delta(k-k')\)</span>. We also showed that these kets are connected by the relation <span class="math display">\[\begin{equation}
\langle k | x \rangle = (2\pi)^{-1/2} e^{-i k x}.
\end{equation}\]</span> In this week’s section, we will use what we learned to build and solve matrix representations of the Hamiltonian for arbitrary 1D potentials using a method called the “Discerete Variable Representation” (DVR). This is a method that is widely used in physics and chemistry to solve for the states and energies of potential energy surfaces needed to describe molecular vibrations, chemical reactions, and beyond.</p>
<p><strong>Learning Goals:</strong> After this Section you should be able to: - Understand when it is more natural to work in a “position” vs.&nbsp;“momentum” basis - Use the sinc basis to express the Hamiltonian for an arbitrary 1D potential - Find the eigenvalues and eigenvectors of Hamiltonians for arbtirary potentials using the discrete variable representation</p>
<section id="motivating-the-sinc-basis-dvr" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="motivating-the-sinc-basis-dvr"><span class="header-section-number">2.1</span> Motivating the Sinc-Basis DVR</h2>
<p>As with previous problems, we’ll first introduce a grid of <span class="math inline">\(N\)</span> equally spaced points on the domain <span class="math inline">\([x_\text{min}, x_\text{max}]\)</span>. The points can be specified as <span class="math display">\[\begin{equation}
x_j = x_\text{min} + (j-1) \Delta x
\end{equation}\]</span> where <span class="math display">\[\begin{equation}
\Delta x = \frac{x_\text{max} - x_\text{min}}{N-1}.
\end{equation}\]</span></p>
<p>Next, we want to set up some basis <span class="math inline">\(\{|\phi_i\rangle\}\)</span> that allows us to express our wavefunction as a superposition of convenient basis functions. Putting this into math based on last week’s section, we want a way to implement the expansion <span class="math display">\[\begin{equation}
\psi(x) = \langle x | \psi \rangle = \sum_{i=1}^{n} c_i \langle x | \phi_i \rangle = \sum_{i=1}^{n} c_i \phi_i(x).
\end{equation}\]</span></p>
<p>There are many possible reasonable choices of this basis, and there is a vast literature of DVR methods that use different choices (some that can’t even be written as nice analytical functions!). But let’s think about what we would want in a general DVR basis set.</p>
<p><strong>Question: What nice properties might we want?</strong></p>
<p><strong>Answer:</strong> Some example of useful properties would be: - We want the basis to satisfy <span class="math inline">\(\langle x_i | x_j \rangle \propto \delta_{i,j}\)</span> - It would be nice if the basis functions were “well behaved” so that we can evaluate derivatives, Fourier transforms, etc.</p>
<p>One example of a set of functions that satisfy these desiderata are the <em>sinc functions</em>: <span class="math display">\[\begin{equation}
\phi_j(x) = \frac{1}{\sqrt{\Delta x}} \frac{\sin[\pi (x-x_j)/\Delta x]}{\pi (x-x_j)/\Delta x} = \frac{1}{\sqrt{\Delta x}} \text{sinc} [\pi (x-x_j)/\Delta x].
\end{equation}\]</span></p>
<p>First of all, let’s explore why these basis functions are useful. It’s best to start this discussion graphically, so let’s use some code to implement the basis and plot the basis functions.</p>
<p>In the space below, we give you some code that defines a grid of x points and a function that implements the sinc-basis. Use these pieces of code to explore the sinc-basis functions and learn about their properties. You are looking to answer questions like the following: - What is the value of a basis function <span class="math inline">\(\phi_j\)</span> at grid point <span class="math inline">\(x_j\)</span>? - What is the value of a basis function <span class="math inline">\(\phi_j\)</span> at a grid point <span class="math inline">\(x_{j+1}\)</span>? At <span class="math inline">\(x_{j+2}\)</span>? - In general, how do the basis functions relate to one another?</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters that we set</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>xmin <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Grid spacing and position-space grid points</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Delta_x <span class="op">=</span> (xmax<span class="op">-</span>xmin)<span class="op">/</span>(N<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> np.linspace(xmin,xmax,N)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>xs_fine <span class="op">=</span> np.arange(xmin,xmax,Delta_x<span class="op">/</span><span class="dv">1000</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Definition of the sinc-basis functions</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> phi(x,xj):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>np.sqrt(Delta_x) <span class="op">*</span> np.sinc((x<span class="op">-</span>xj)<span class="op">/</span>Delta_x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are two useful ways that we can look at these basis functions. First of all, we can plot an example like <span class="math inline">\(\phi_3(x_j)\)</span> to look at the <span class="math inline">\(i=3\)</span> basis function evaluated at each grid point. If we overlay this with a plot of <span class="math inline">\(\phi_3(x)\)</span> evaluated on a much finer grid, we see that the sinc-basis is defined such that a given basis function <span class="math inline">\(\phi_i\)</span> is nonzero at grid point <span class="math inline">\(x_i\)</span>, and its oscillations ensure that it passes through zero at every other grid point!</p>
<p><strong>Question:</strong> Does it matter that the sinc function takes on nonzero values away from the <span class="math inline">\(i\neq j\)</span> grid points?</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="13">
<div class="cell-output cell-output-display">
<p><img src="Section4_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>It can also be useful to look at a series of these sinc functions centered at different grid points. Notice where they all pass through zero, and where each individual basis function doesn’t pass through zero.</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="14">
<div class="cell-output cell-output-display">
<p><img src="Section4_files/figure-html/cell-5-output-1.png" class="img-fluid"></p>
</div>
</div>
<section id="interpreting-the-sinc-basis" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="interpreting-the-sinc-basis"><span class="header-section-number">2.1.1</span> Interpreting the Sinc-Basis</h3>
<p><strong>Question:</strong> In light of these plots, how can we interpret the sinc-basis functions as compared to a set of Dirac delta functions?</p>
<p><strong>Answer:</strong> This is a finite resolution basis that is like the closest possible approximation to a delta function that we can make for a given range on the number of momentum basis functions that our spatial grid can accomodate. As the plots above show, we means this in the sense that these basis states satisfy <span class="math display">\[\begin{equation}
\phi_j(x_k) \propto \delta_{k,j},
\end{equation}\]</span> so a given basis function only gives a nonzero contribution to a function at the point at which that basis function is centered.</p>
<p>The sinc basis has a nice relationship to the Fourier transforms that we discussed last week. In particular, the sinc basis functions can be written as follows: <span class="math display">\[\begin{equation}
\phi_j(x) = \frac{\sqrt{\Delta x}}{2\pi} \int_{-\pi/\Delta x}^{\pi/\Delta x} e^{i k(x-x_j)} dk
\end{equation}\]</span></p>
<p><strong>Question:</strong> Can you justify this form qualitatively? How does it relate to Fourier transforms that we studied last week? And why are the limits on the integral those numbers?</p>
</section>
</section>
<section id="deriving-the-kinetic-energy-matrix" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="deriving-the-kinetic-energy-matrix"><span class="header-section-number">2.2</span> Deriving the Kinetic Energy Matrix</h2>
<p>Now that we have a useful basis, we can try to solve problems with it. We still need to learn how to express the Hamiltonian in this basis. Since the Hamiltonian is <span class="math display">\[\begin{equation}
H = -\frac{\hbar^2}{2m} \frac{d^2}{dx^2} + V(x)
\end{equation}\]</span> we need to figure out how to express the second derivative operator and the <span class="math inline">\(V(x)\)</span> operator in our chosen basis.</p>
<p>Let’s start with the kinetic energy term. We want to derive a kinetic energy matrix with matrix elements <span class="math display">\[\begin{equation}
T_{ij} = -\frac{\hbar^2}{2m} \left \langle \phi_i \left\lvert \frac{d^2}{dx^2} \right\rvert \phi_j \right \rangle.
\end{equation}\]</span></p>
<p>It turns out this is where the Fourier transform expression is super helpful. We can go through the following steps: <span class="math display">\[\begin{equation}
\int_{-\infty}^{\infty} \phi_i^\ast(x) \frac{d^2}{dx^2} \phi_j(x) dx = \frac{\Delta x}{(2\pi)^2} \int_{-\infty}^{\infty} dx \int_{-\pi/\Delta x}^{\pi/\Delta x} e^{-i k (x-x_i)} dk \int_{-\pi/\Delta x}^{\pi/\Delta x} \left( \frac{d^2}{dx^2} e^{i k' (x-x_j)} \right) dk'
\end{equation}\]</span></p>
<p>Because we’ve expressed the basis function in terms of plane waves, evaluating <span class="math inline">\(\frac{d^2}{dx^2}\)</span> is really easy: it just corresponds to pulling down a factor of <span class="math inline">\((ik)^2\)</span>. That gets us to <span class="math display">\[\begin{equation}
\frac{\Delta x}{(2\pi)^2} \int_{-\pi/\Delta x}^{\pi/\Delta x} (ik)^2 e^{i k (x_i - x_j)} dk.
\end{equation}\]</span></p>
<p>If you work through these integrals, you will find that: <span class="math display">\[\begin{equation}
\boxed{T_{i,j=i} = \frac{\hbar^2}{2m \Delta x^2} \frac{\pi^2}{3}}
\end{equation}\]</span> and <span class="math display">\[\begin{equation}
\boxed{T_{i,j \neq i} = \frac{\hbar^2}{2m \Delta x^2} \frac{2 (-1)^{i-j}}{(i-j)^2}}
\end{equation}\]</span></p>
<p><strong>Task:</strong> Now fill in the code below to make a function that builds the kinetic energy operator and the potential energy operator.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># work in some convenient units</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>hbar <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the kinetic energy operator</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_T(x):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    Delta_x <span class="op">=</span> x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> xs.shape[<span class="dv">0</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    Tmat <span class="op">=</span> np.zeros((N,N))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now loop over kinetic energy matrix and fill in matrix elements</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i<span class="op">==</span>j:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                Tmat[i,j] <span class="op">=</span> (hbar<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m<span class="op">*</span>Delta_x<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">**</span>(i<span class="op">-</span>j) <span class="op">*</span> (np.pi<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">3</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                Tmat[i,j] <span class="op">=</span> (hbar<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>m<span class="op">*</span>Delta_x<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>)<span class="op">**</span>(i<span class="op">-</span>j) <span class="op">*</span> <span class="dv">2</span><span class="op">/</span>(i<span class="op">-</span>j)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Tmat</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="deriving-the-potential-energy-matrix" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="deriving-the-potential-energy-matrix"><span class="header-section-number">2.3</span> Deriving the Potential Energy Matrix</h2>
<p>For the potential energy matrix, we need to express <span class="math inline">\(V(x)\)</span> in matrix form. Since <span class="math inline">\(V(x)\)</span> can be expanded as a power series in the position operator <span class="math inline">\(\hat{x}\)</span>, let’s first look at the matrix form of <span class="math inline">\(\hat{x}\)</span> itself. We want the matrix elements <span class="math inline">\(x_{ij} = \langle \phi_i | x | \phi_j \rangle\)</span>. In other words, we want <span class="math display">\[\begin{equation}
\int_{-\infty}^{\infty} \phi_i(x)^\ast x \phi_j(x) dx = \frac{\Delta x}{(2\pi)^2} \int_{-\pi/\Delta x}^{\pi/\Delta x} dk \int_{-\pi/\Delta x}^{\pi/\Delta x} dk' e^{ikx_i - ik'x_j} \int_{-\infty}^{\infty} x e^{i x (k'-k)} dx.
\end{equation}\]</span> In the last term, note that we can replace <span class="math inline">\(x\)</span> by <span class="math inline">\(\frac{d}{d(ik')}\)</span> and then pull the derivative outside of the integral over <span class="math inline">\(x\)</span> (since it doesn’t depend on <span class="math inline">\(x\)</span> anymore). Working through the integrals after that step, we get to <span class="math display">\[\begin{equation}
x_{ij} = \frac{\Delta x}{2\pi} x_i \int_{-\pi/\Delta x}{\pi/\Delta x} dk' e^{ik'(x_i-x_j)} = x_i \delta_{i,j}.
\end{equation}\]</span></p>
<p><strong>The important conclusion is that <span class="math inline">\(\hat{x}\)</span> is diagonal in this basis!</strong> So the potential energy, which can be expanded in powers of <span class="math inline">\(x\)</span> is also diagonal in this basis! Knowing this, we can just make the potential energy operator by building a diagonal matrix from <span class="math inline">\(V(x)\)</span>. The function <code>make_V</code> does this, and then the function <code>make_H</code> just calls the kinetic and potential energy functions and puts them together.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the potential energy operator</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_V(x,Vfunc):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Vmat <span class="op">=</span> np.diag(Vfunc(x))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Vmat</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the full Hamiltonian</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_H(x,Vfunc):</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_T(x) <span class="op">+</span> make_V(x,Vfunc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="testing-the-dvr-code" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="testing-the-dvr-code"><span class="header-section-number">2.4</span> Testing the DVR code</h2>
<p>That was a lot of work to get our Hamiltonian matrix. But now let’s see the payoff! We’ll see that the DVR code is incredibly accurate, especially compared to the finite differences method that we used before. As always let’s test our code by using a harmonic oscillator potential. Let’s start with a 20 point grid and see how the calculations do for energies and wavefunctions.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Vharmonic(x):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Ham <span class="op">=</span> make_H(xs,Vharmonic)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>vals, vecs <span class="op">=</span> np.linalg.eigh(Ham)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>vals[<span class="dv">0</span>:<span class="dv">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>array([0.50042652, 1.49199271, 2.54377448, 3.30864454])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plt.plot(xs,vecs[:,<span class="dv">0</span>:<span class="dv">3</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="Section4_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Let’s look at the accuracy of our solutions as a function of quantum number.</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="22">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>Nlist <span class="op">=</span> [<span class="dv">50</span>,<span class="dv">60</span>,<span class="dv">75</span>,<span class="dv">100</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist)):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> <span class="dv">20</span><span class="op">/</span>Nlist[i]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,Nlist[i])</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    Ham <span class="op">=</span> make_H(xs,Vharmonic)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    vals, vecs <span class="op">=</span> np.linalg.eigh(Ham)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    energies_exact <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> np.arange(<span class="dv">0</span>,<span class="bu">len</span>(xs),<span class="dv">1</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    errors <span class="op">=</span> np.<span class="bu">abs</span>(vals <span class="op">-</span> energies_exact)<span class="op">/</span>energies_exact</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    plt.semilogy(np.arange(<span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">1</span>),errors[<span class="dv">0</span>:<span class="dv">50</span>])</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>plt.legend([Nlist[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist))])</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Quantum number, n"</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Fractional error"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>Text(0, 0.5, 'Fractional error')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Section4_files/figure-html/cell-13-output-2.png" class="img-fluid"></p>
</div>
</div>
<p><strong>Question:</strong> Explain the differences between the case with 50 grid points and the case with 60 grid points. Why is the agreement better to higher <span class="math inline">\(n\)</span> for 60 grid points? Also, why does the agreement seem to always get worse above <span class="math inline">\(n \sim 25\)</span>, even if the number of grid points is increased?</p>
<section id="comparing-dvr-to-finite-differences" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="comparing-dvr-to-finite-differences"><span class="header-section-number">2.4.1</span> Comparing DVR to Finite Differences</h3>
<p>Let’s look at the accuracy of the numerical solution as a function of the number of grid points. We can compare this to the results of HW 1 to see how the DVR method does against finite differences.</p>
<p>In this block, write a function that computes the fractional error in the SHO eigenstates as a function of the number of grid points used.</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="23">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Nlist <span class="op">=</span> np.logspace(<span class="dv">1</span>,<span class="fl">2.5</span>,<span class="dv">10</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>errorlist <span class="op">=</span> np.zeros(<span class="bu">len</span>(Nlist))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist)):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> Nlist[i]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> np.arange(<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">20</span><span class="op">/</span>Nlist[i])</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> make_H(xs,Vharmonic)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    evals, evecs <span class="op">=</span> np.linalg.eigh(H)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    errorlist[i] <span class="op">=</span> np.<span class="bu">abs</span>(evals[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">0.5</span>)<span class="op">/</span><span class="fl">0.5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This next block is already written for you– nothing you need to do!— to implement and solve the same problem using the Numerov method. The code is taken from the HW1 solutions.</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="24">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the A matrix:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> makeA(N,h):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.zeros((N,N))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        A[i,i] <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span><span class="op">/</span>h<span class="op">**</span><span class="dv">2</span> <span class="co"># fill in diagonal</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span>: <span class="co"># the first row looks like [-2,1,0,0,0...]/h^2</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            A[i,i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>h<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i<span class="op">==</span>N<span class="op">-</span><span class="dv">1</span>: <span class="co"># the last row looks like [...,0,0,1,-2]/h^2</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            A[i,i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>h<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># all other rows look like [...0,1,-2,1,0,...]/h^2</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            A[i,i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>h<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            A[i,i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>h<span class="op">**</span><span class="dv">2</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the B matrix:</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> makeB(N):</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.zeros((N,N))</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        B[i,i] <span class="op">=</span> <span class="fl">10.0</span><span class="op">/</span><span class="dv">12</span> <span class="co"># fill in diagonal</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            B[i,i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> i<span class="op">==</span>N<span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            B[i,i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>            B[i,i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>            B[i,i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">12</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to make the Hamiltonian matrix on a grid of N points between (xmin,xmax), then find eigenvalues/eigenvectors.</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="co"># The potential energy Vfunc is an arbitrary function that gets passed in and discretized inside of this function.</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve(N,xmin,xmax,Vfunc):</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(xmin,xmax,N) <span class="co"># grid of x values</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> x[<span class="dv">1</span>]<span class="op">-</span>x[<span class="dv">0</span>] <span class="co"># grid spacing</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># make the A and B matrices</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> makeA(N,h)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> makeB(N)</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    Tmat <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> np.linalg.inv(B) <span class="op">@</span> A <span class="co"># This is the matrix representing kinetic energy.</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># put the potential energy onto a grid and then put that into a diagonal matrix</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    Vgrid <span class="op">=</span> np.zeros(N)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>        Vgrid[i] <span class="op">=</span> Vfunc(x[i])</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    Vmat <span class="op">=</span> np.diag(Vgrid)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Finally we get the whole Hamiltonian</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    Hmat <span class="op">=</span> Tmat <span class="op">+</span> Vmat</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now diagonalize the Hamiltonian. </span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eigh returns sorted values and vectors!</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    evals, evecs <span class="op">=</span> np.linalg.eigh(Hmat)</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> evals, evecs</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="co"># NOW ACTUALLY CALL THE NUMEROV METHOD</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>vals_numerov, vecs_numerov <span class="op">=</span> solve(<span class="dv">1000</span>, <span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>, Vharmonic)</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>errorlist_numerov <span class="op">=</span> np.zeros(<span class="bu">len</span>(Nlist))</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist)):</span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">round</span>(Nlist[i])</span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>    vals_num, vecs_num <span class="op">=</span> solve(N,<span class="op">-</span><span class="dv">10</span>,<span class="dv">10</span>,Vharmonic)</span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    errorlist_numerov[i] <span class="op">=</span> np.<span class="bu">abs</span>(vals_num[<span class="dv">0</span>] <span class="op">-</span> <span class="fl">0.5</span>)<span class="op">/</span><span class="fl">0.5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, make a plot of the relative errors comparing the numerov and DVR methods for the ground state as a function of the grid spacing <span class="math inline">\(\Delta x\)</span>.</p>
<div class="cell" data-tags="[&quot;hide-input&quot;]" data-execution_count="25">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>plt.loglog([<span class="dv">20</span><span class="op">/</span>Nlist[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist))],errorlist, label<span class="op">=</span><span class="st">"DVR method"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plt.loglog([<span class="dv">20</span><span class="op">/</span>Nlist[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(Nlist))],errorlist_numerov, <span class="st">'r'</span>, label<span class="op">=</span><span class="st">"Numerov method"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"dx"</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Fractional error"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>Text(0, 0.5, 'Fractional error')</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="Section4_files/figure-html/cell-16-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Clearly the DVR method is much better than the Numerov technique! For reasonable grid sizes, the DVR method gets the ground-state energy with almost 10 orders of magnitude better relative agreement!! (And remember, the Numerov method was already much better than a “plain” second-order finite differences approximation to the Hamiltonian…)</p>
<p><strong>Question:</strong> Why do you think the DVR method stops getting more accurate at a certain step size? What does this tell you about setting up simulations?</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Section2.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Section 2: Numerically Solving the TDSE</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Section6.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Section 6: An Intuitive Picture of Band Structure</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>